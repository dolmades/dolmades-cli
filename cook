#!/usr/bin/env python

import shutil
import stat
import getpass
import sys
import subprocess
import os
import re
import hashlib
import pycurl         # FIXME get rid of this dependency

import config as cfg

def createDirectories():
    if (not os.path.exists(cfg.DOLMADES_PATH)):
        os.mkdir(cfg.DOLMADES_PATH, 0755)
    try:
        if (os.path.exists(cfg.REPO_PATH)):
            os.rmdir(cfg.REPO_PATH)
    except:
        print(cfg.REPO_PATH+" not empty, do not delete...")
    if (not os.path.exists(cfg.INST_PATH)):
        os.mkdir(cfg.INST_PATH, 0755)

class Ingredient(object):

    def __init__(self, h, fn, dn, u):
        self.sha256hash = h
        self.displayName = dn
        self.fileName = fn
        self.urls = list()
        self.local_urls = list()
        self.gog_urls = list()
        self.addUrl(u)

    def addUrl(self, u):
        if (u.startswith('gog://')):
            self.gog_urls.append(u)
            return

        if (u.startswith('file://')):
            self.local_urls.append(u)
            return

        self.urls.append(u)


    def downloadProgress(self, download_t, download_d, upload_t, upload_d):
        try:
            frac = float(download_d)/float(download_t)
        except:
            frac = 0
        sys.stdout.write("\r%s %3i%%" % ("Download:", frac*100)  )
        if (frac > 99.999):
            print('')

    def checklocal(self):
        try:
            sha256 = hashlib.sha256()
            block_size=65536
            if not os.path.isfile(cfg.INST_PATH + "/" + self.fileName):
                print('File has yet to be retrieved!')
                return False
            with open(cfg.INST_PATH + "/" + self.fileName, 'rb') as f:
                for block in iter(lambda: f.read(block_size), b''):
                    sha256.update(block)
            if (sha256.hexdigest() != self.sha256hash):
                print('Error: '+self.fileName+' invalid hash sum for ingredient')
                return False
            else:
                print('Good: '+self.fileName+' hash sum correct!')
                return True
        except Exception as error:
            print("Caught " + repr(error))
            return False

    def retrieve(self):
        if self.checklocal():
            return True

        # try to use local copy of the ingredient if available
        for u in self.local_urls:
            try:
                print("Using local copy of " + self.fileName + " from " + u)
                shutil.copy(u.replace('file://',''), cfg.INST_PATH + "/" + self.fileName)
                if self.checklocal():
                    return True
                else:
                    continue
            except Exception as error:
                print(error)
                continue
        
        # try to obtain file via GOG downloader
        for u in self.gog_urls:
            try:
                print("Using a valid GOG account to download " + u + " as " + self.fileName)
                cmd = cfg.SELF_PATH + '/udocker' + " --quiet --repo=" + cfg.REPO_PATH+\
                      " run --user=$(whoami) --bindhome --hostauth -v " + cfg.INST_PATH+\
                      "/:/wineprefix dolmades-runtime bash -c 'cd /wineprefix && lgogdownloader --download-file "+\
                      u.replace("gog://","")+"'"
                print(cmd)
                subprocess.call(cmd, shell=True, close_fds=True)
                
            except Exception as error:
                print(error)
                continue

        # try to retrieve ingredient from remote locations
        for u in self.urls:
            try:
                print("Retrieving " + self.fileName + " from " + u)
                cmd = cfg.SELF_PATH+'/udocker'+" --quiet --repo="+cfg.REPO_PATH+\
                      " run --user=$(whoami) --volume="+cfg.INST_PATH+":/"+cfg.INST_DIR+" dolmades-runtime sh -c 'curl -o /"+cfg.INST_DIR+"/\""+self.fileName+"\" \""+u+"\"'"
                print(cmd)
                subprocess.call(cmd, shell=True, close_fds=True)

                if self.checklocal():
                    return True   
                else:
                    continue
            except Exception as error:
                print('\nCaught: ' + repr(error))
                continue

        return False


class Dolmade(object):

    udocker=cfg.SELF_PATH + '/udocker'
    udockerCmd=udocker+" --quiet --repo="+cfg.REPO_PATH
    iconfn = None
    name = None
    sha256 = None
    ingredients = []
    runs = []

    def __init__(self):
        self.version = "latest"
        self.prepareDirectories()

        cmd = self.udockerCmd+" inspect dolmades-runtime"
        try:
            outp = subprocess.check_output(cmd, shell=True, close_fds=True, stderr=subprocess.STDOUT)
            if (outp != ""):
                print("Dolmades Runtime found")
        except:
            self.prepareRuntime()

    def prepareDirectories(self):
        untouched = True
        if (not os.path.exists(cfg.DOLMADES_PATH)):
            os.mkdir(cfg.DOLMADES_PATH, 0755)
            untouched = False
        try:
            if (os.path.exists(cfg.REPO_PATH)):
                os.rmdir(cfg.REPO_PATH)
                untouched = False
        except:
            pass

        if (not os.path.exists(cfg.REPO_PATH)):
            cmd = cfg.SELF_PATH + "/udocker mkrepo "+cfg.REPO_PATH
            print(cmd)
            subprocess.call(cmd, shell=True, close_fds=True)
            untouched = False

        if (not os.path.exists(cfg.INST_PATH)):
            os.mkdir(cfg.INST_PATH, 0755)
            untouched = False
        if (untouched):
            print("Found dolmade repo under " + cfg.REPO_PATH)
        else:
            print("Initialized dolmade repo under " + cfg.REPO_PATH)

    def prepareRuntime(self):
        print("Preparing Dolmades Runtime...")

        cmd = self.udockerCmd+" pull dolmades/runtime:"+cfg.VERSION
        print("Pulling dolmades runtime container...")
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udockerCmd + " rm dolmades-runtime"
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udockerCmd + " create --name=dolmades-runtime dolmades/runtime:"+cfg.VERSION
        subprocess.call(cmd, shell=True, close_fds=True)

        if (not os.path.exists(cfg.REPO_PATH+"/containers/dolmades-runtime/ROOT/"+cfg.META_DIR)):
            os.mkdir(cfg.REPO_PATH+"/containers/dolmades-runtime/ROOT/"+cfg.META_DIR, 0755)

        print("done")


    def dumpComment(self, cmdp):
        if (False):
            print(cmdp)

    def checkVersion(self, version):
        self.version=''.join(version)
        if self.version == cfg.VERSION:
            print("Good! The dolmadefile and this script both match version "+self.version)
        else:
            print("Bad! The dolmadefile is for version "+self.version+", but this script for version "+cfg.VERSION)
            sys.exit(1)

    def setupDolmade(self, cmdp):
        self.name = ' '.join(cmdp)
        print("Setting Dolmade Name to " + self.name)

    def setupBase(self, cmdp):
        self.baseImg = ''.join(cmdp)
        print("Setting Base Docker Image to " + self.baseImg)

    def setupDescription(self, cmdp):
        self.description = '\n'.join(cmdp)
        print("Setting Description to " + self.description)

    def setupIngredient(self, cmdp):
        h = cmdp[0]
        fn = cmdp[1]
        dn = cmdp[2]
        u = cmdp[3]

        sys.stdout.write("Adding Ingredient " + dn + ":" + fn + ":" + h + ":" + u)
        ingr = Ingredient(h,fn,dn,u)
        
        for i in range(4,len(cmdp)):
            isInvalid = True
            for url_pf in ['http://', 'https://', 'ftp://', 'file://', 'gog://']:
                if (cmdp[i].startswith(url_pf)): 
                    sys.stdout.write(":" + cmdp[i])
                    ingr.addUrl(cmdp[i])
                    isInvalid = False
            if isInvalid:
                raise Exception("Malformed Url "+cmdp[i])

        self.ingredients.append(ingr)
        print("")

    def run(self, cmdp):
        print("Running as User:" + ' '.join(cmdp))
        self.runs.append(('user',cmdp))

    def runRoot(self, cmdp):
        print("Running as Root:" + ' '.join(cmdp))
        self.runs.append(('root',cmdp))

    def icon(self, cmdp):
        self.iconfn = ''.join(cmdp)
        print("Selecting Icon:" + self.iconfn)

    def setTarget(self, cmdp):
        self.runs.append(('setTarget', cmdp))
        print("Determine target path by running:" + ' '.join(cmdp))

    def setTargetBind(self, cmdp):
        targetBinds.append(cmdp)
        print("Bind mount for target run:" + join(cmdp))
        
    def path(self):
        if self.sha256:
            return cfg.REPO_PATH+"/containers/"+self.sha256+"/ROOT/"
        else:
            print("Error: Dolmade has not been created yet!")
            return None

    def metaPath(self):
        path = self.path()
        if path:
            return self.path()+"/"+cfg.META_DIR
        else:
            return None

    def installPath(self):
        return self.path()+"/"+cfg.INST_DIR

    def build(self):
        print("Performing the dolmade build...")
        for i in self.ingredients: 
            i.retrieve()

        cmd = self.udocker + " mkrepo " + cfg.REPO_PATH
        print cmd
        try:
            outp = subprocess.check_output(cmd, shell=True, close_fds=True, stderr=subprocess.STDOUT)
        except:
            print("Repo exists already")

        cmd = self.udockerCmd+" pull "+self.baseImg+":"+self.version
        print cmd
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udockerCmd+" create "+self.baseImg+":"+self.version
        self.sha256 = subprocess.check_output(cmd, shell=True, close_fds=True).strip()

        if (not os.path.exists(self.metaPath())):
            os.mkdir(self.metaPath(), 0755)
        
        print("Installing the sucessfully built dolmade...")

        cmd = self.udockerCmd+" rm "+self.name
        print(cmd)
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udockerCmd+" name "+self.sha256+" "+self.name
        print(cmd)
        subprocess.call(cmd, shell=True, close_fds=True)

        self.target = None
        self.targetPath = None

        for r in self.runs:
            (u,c) = r
            if (u == 'root'):
                cmd = self.udockerCmd+" run --volume="+cfg.INST_PATH+":/install --user=root --volume="+os.path.expanduser("~")+\
                      "/.Xauthority --hostenv --dri "+self.name+" "+"bash -c 'cd /install && "+' '.join(c)+"'"
                subprocess.call(cmd, shell=True, close_fds=True)
            if (u == 'user'):
                cmd = self.udockerCmd+" run --volume="+cfg.INST_PATH+":/install --user="+getpass.getuser()+" --volume="+os.path.expanduser("~")+\
                      "/.Xauthority --hostenv --dri " + self.name + " " + "bash -c 'cd /install && " + ' '.join(c) + "'"
                print(cmd)
                subprocess.call(cmd, shell=True, close_fds=True)
            if (u == 'setTarget'):
                cmd = self.udockerCmd+" run --user="+getpass.getuser()+" --hostenv "+self.name+" bash -c '"+' '.join(c)+"'"
                print(cmd)
                try:
                    outp = subprocess.check_output(cmd, shell=True, close_fds=True, stderr=subprocess.STDOUT)
                    outp = outp.strip()
                    self.target = ''.join(outp.split('/')[-1])
                    self.targetPath = '/'.join(outp.split('/')[:-1])
                except:
                    print("ERROR: could not determine target path!")

        descInContainer = self.metaPath()+"/description.txt"
        f = open(descInContainer, 'w')
        try:
            f.write(self.description)
        except:
            print("No description predefined.")
        f.close()

        if (self.target):
            print("Predefined target is "+self.target+", target path is "+self.targetPath)
            self.target = 'wine "'+self.target+'"'
        else:
            print("No target predefined. Target launcher will be used.")
            self.target="./targetLauncher"
            self.targetPath="/usr/local/bin"

        iconInContainer = self.metaPath()+"/icon.png"
        open(iconInContainer, 'w+')
        cmd = self.udockerCmd+" run --user="+getpass.getuser()+" -v=" + cfg.INST_PATH+"/"+self.iconfn+":/"+self.iconfn+\
              " -v="+iconInContainer+":/wineprefix/icon.png dolmades-runtime sh -c 'convert -adaptive-resize 128x128 /"+\
              self.iconfn + "[0] " + "/wineprefix/icon.png'"
        print(cmd)
        subprocess.call(cmd, shell=True, close_fds=True)

        namefileInContainer = self.metaPath()+"/dolmadename"
        cleanName=self.name.replace('_',' ').replace('&',"_n_")
        subprocess.call("echo '"+cleanName+"' > "+namefileInContainer, shell=True, close_fds=True)

        deskfileOnHost = cfg.DESK_PATH + "/" + self.name + ".desktop"
        with open(deskfileOnHost, "w") as text_file:
            text_file.write("[Desktop Entry]\nEncoding=UTF-8\nValue=1.0\nType=Application\n")
            text_file.write("Name="+cleanName+"\nGenericName="+cleanName+"\nComment=" +cleanName+"\n")
            text_file.write("Icon="+self.metaPath()+"/icon.png"+"\n")
            text_file.write("Exec="+cfg.SELF_PATH+"/dolmades launch '"+self.name+"'\n")
            text_file.write("Categories=Game;\n")
            text_file.write("Path="+os.path.expanduser("~")+"\n")

        runscriptInContainer = self.metaPath()+"/start.sh"

        with open(runscriptInContainer, "w") as text_file:
            text_file.write("#!/bin/bash\n")
            text_file.write('cd "'+self.targetPath+'"\n')
            text_file.write(self.target+"\n")

        st = os.stat(deskfileOnHost)
        os.chmod(deskfileOnHost, st.st_mode | stat.S_IEXEC)
        st = os.stat(runscriptInContainer)
        os.chmod(runscriptInContainer, st.st_mode | stat.S_IEXEC)

class Main(object):
    dolmade = Dolmade()

    def executeCmd(self, cmdarg):
        """all supported commands"""
        cmds = { '': self.dolmade.dumpComment,
                 '#': self.dolmade.dumpComment,
                 'VERSION': self.dolmade.checkVersion,
                 'DOLMADE': self.dolmade.setupDolmade, 
                 'BASE': self.dolmade.setupBase,
                 'DESCRIPTION': self.dolmade.setupDescription,
                 'INGREDIENT': self.dolmade.setupIngredient,
                 'RUNUSER': self.dolmade.run,
                 'RUNROOT': self.dolmade.runRoot,
                 'ICON': self.dolmade.icon,
                 'SETTARGET': self.dolmade.setTarget,
                 'TARGETBIND': self.dolmade.setTargetBind }

        if len(cmdarg)<1:
            return

        cmd = cmdarg[0]
        arg = cmdarg[1:len(cmdarg)]

        if (cmd in cmds):
            cmds[cmd](arg)
        else:
            raise Exception('Unknown instruction ' + cmd + ":" + " ".join(cmdarg))


    def execute(self):
        if (len(sys.argv)==1):
            inputFileName = os.getcwd() + "/Dolmadefile"
        else:
            inputFileName = sys.argv[1];

        try:
            with open(inputFileName, "r") as dolmadeFile:
                cmdarg = list()
                while True:
                    line = dolmadeFile.readline();
                    if line:
                        if line.strip().startswith('#'):
                            continue
                        if line.startswith((' ','\t')) and not line.strip() == "":
                            cmdarg.append(line.strip())
                        else:
                            self.executeCmd(cmdarg)
                            cmdarg = list()
                            cmdarg.append(line.strip())
                    else:
                        break

                self.executeCmd(cmdarg)

        except (IOError, OSError):
            print("ERROR: Cannot open " + inputFileName)

        self.dolmade.build()

    def start(self):
        """Program start and exception handling"""
        try:
            createDirectories()
            exit_status = self.execute()
        except (KeyboardInterrupt, SystemExit):
            self.cleanup()
            return 1
        except:
            self.cleanup()
            raise
        else:
            self.cleanup()
            return exit_status

    def cleanup(self):
        print("Deleting all temporary files...")


if __name__ == "__main__":
    sys.exit(Main().start())
