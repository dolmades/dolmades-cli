#!/usr/bin/env python

import shutil
import stat
import getpass
import sys
import subprocess
import os
import re
import hashlib
import pycurl         # FIXME get rid of this dependency

__author__ = "stefan.kombrink@gmail.com"
__credits__ = ["UDocker https://github.com/indigo-dc/udocker",
               "PRoot http://proot.me",
               "runC https://runc.io"]
__license__ = "Licensed under the Apache License, Version 2.0"
__version__ = "0.1"
__date__ = "2018"

VERSION = "1.0"
# Python version major.minor
PY_VER = "%d.%d" % (sys.version_info[0], sys.version_info[1])
START_PATH = os.path.dirname(os.path.realpath(sys.argv[0]))
DOLMADES_PATH = os.path.expanduser('~')+'/.dolmades'

REPO_PATH = DOLMADES_PATH + "/repo"
INST_PATH = DOLMADES_PATH + "/install"

try:
    DESK_PATH = subprocess.check_output(['xdg-user-dir', 'DESKTOP']).strip()
except:
    DESK_PATH = os.path.expanduser("~/Desktop")

def createDirectories():
    if (not os.path.exists(DOLMADES_PATH)):
        os.mkdir(DOLMADES_PATH, 0755)
    try:
        if (os.path.exists(REPO_PATH)):
            os.rmdir(REPO_PATH)
    except:
        print(REPO_PATH+" not empty, do not delete...")
    if (not os.path.exists(INST_PATH)):
        os.mkdir(INST_PATH, 0755)

class Ingredient(object):

    def __init__(self, h, fn, dn, u):
        self.sha256hash = h
        self.displayName = dn
        self.fileName = fn
        self.urls = list()
        self.local_urls = list()
        self.gog_urls = list()
        self.addUrl(u)

    def addUrl(self, u):
        if (u.startswith('gog://')):
            self.gog_urls.append(u)
            return

        if (u.startswith('file://')):
            self.local_urls.append(u)
            return

        self.urls.append(u)


    def downloadProgress(self, download_t, download_d, upload_t, upload_d):
        try:
            frac = float(download_d)/float(download_t)
        except:
            frac = 0
        sys.stdout.write("\r%s %3i%%" % ("Download:", frac*100)  )
        if (frac > 99.999):
            print('')

    def checklocal(self):
        try:
            sha256 = hashlib.sha256()
            block_size=65536
            if not os.path.isfile(INST_PATH + "/" + self.fileName):
                print('File has yet to be retrieved!')
                return False
            with open(INST_PATH + "/" + self.fileName, 'rb') as f:
                for block in iter(lambda: f.read(block_size), b''):
                    sha256.update(block)
            if (sha256.hexdigest() != self.sha256hash):
                print('Error: invalid hash sum for ingredient')
                return False
            else:
                print('Good: hash sum correct!')
                return True
        except Exception as error:
            print("Caught " + repr(error))
            return False

    def retrieve(self):
        if self.checklocal():
            return True

        # try to use local copy of the ingredient if available
        for u in self.local_urls:
            try:
                print("Using local copy of " + self.fileName + " from " + u)
                shutil.copy(u.replace('file://',''), INST_PATH + "/" + self.fileName)
                if self.checklocal():
                    return True
                else:
                    continue
            except Exception as error:
                print(error)
                continue
        
        # try to obtain file via GOG downloader
        for u in self.gog_urls:
            try:
                print("Using a valid GOG account to download " + u + " as " + self.fileName)
                cmd = START_PATH + '/udocker' + " --quiet --repo=" + REPO_PATH + " run --user=$(whoami) --bindhome --hostauth -v " + INST_PATH+"/:/wineprefix dolmades-runtime bash -c 'cd /wineprefix && lgogdownloader --download-file "+u.replace("gog://","")+"'"
                print(cmd)
                subprocess.call(cmd, shell=True, close_fds=True)
                
            except Exception as error:
                print(error)
                continue

        # try to retrieve ingredient from remote locations
        for u in self.urls:
            try:
                print("Retrieving " + self.fileName + " from " + u)
                with open(INST_PATH + "/" + self.fileName, 'wb') as f:
                    c = pycurl.Curl()
                    c.setopt(c.VERBOSE, False)
                    c.setopt(pycurl.HEADER, 0)
                    c.setopt(pycurl.FOLLOWLOCATION, 1)
                    c.setopt(pycurl.MAXREDIRS, 5)
                    c.setopt(pycurl.CONNECTTIMEOUT, 30)
                    c.setopt(pycurl.TIMEOUT, 300)
                    c.setopt(pycurl.NOSIGNAL, 1)
                    c.setopt(pycurl.NOPROGRESS, 0)
                    c.setopt(pycurl.PROGRESSFUNCTION, self.downloadProgress)
                    c.setopt(c.URL, u)
                    c.setopt(c.WRITEDATA, f)
                    c.perform()
                    c.close()
                if self.checklocal():
                    return True   
                else:
                    continue
            except Exception as error:
                print('\nCaught: ' + repr(error))
                continue

        return False


class Dolmade(object):

    udocker=START_PATH + '/udocker'
    udockerCmd=udocker + " --quiet --repo=" + REPO_PATH
    iconfn = None
    installDir=START_PATH + '/install'
    name = None
    sha256 = None
    ingredients = []
    runs = []

    def __init__(self):
        self.version = "latest"
        self.prepareDirectories()

        cmd = self.udockerCmd+" inspect dolmades-runtime"
        try:
            outp = subprocess.check_output(cmd, shell=True, close_fds=True, stderr=subprocess.STDOUT)
            if (outp != ""):
                print("Dolmades Runtime found")
        except:
            self.prepareRuntime()

    def prepareDirectories(self):
        untouched = True
        if (not os.path.exists(DOLMADES_PATH)):
            os.mkdir(DOLMADES_PATH, 0755)
            untouched = False
        try:
            if (os.path.exists(REPO_PATH)):
                os.rmdir(REPO_PATH)
                untouched = False
        except:
            pass

        if (not os.path.exists(REPO_PATH)):
            cmd = START_PATH + "/udocker mkrepo "+REPO_PATH
            print(cmd)
            subprocess.call(cmd, shell=True, close_fds=True)
            untouched = False

        if (not os.path.exists(INST_PATH)):
            os.mkdir(INST_PATH, 0755)
            untouched = False
        if (untouched):
            print("Found dolmade repo under " + REPO_PATH)
        else:
            print("Initialized dolmade repo under " + REPO_PATH)

    def prepareRuntime(self):
        print("Preparing Dolmades Runtime...")

        cmd = self.udockerCmd+" pull dolmades/runtime:"+VERSION
        print("Pulling dolmades runtime container...")
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udockerCmd + " rm dolmades-runtime"
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udockerCmd + " create --name=dolmades-runtime dolmades/runtime:"+VERSION
        subprocess.call(cmd, shell=True, close_fds=True)
        print("done")


    def dumpComment(self, cmdp):
        if (False):
            print(cmdp)

    def checkVersion(self, version):
        self.version=''.join(version)
        if self.version == VERSION:
            print("Good! The dolmadefile and this script both match version "+self.version)
        else:
            print("Bad! The dolmadefile is for version "+self.version+", but this script for version "+VERSION)
            sys.exit(1)

    def setupDolmade(self, cmdp):
        self.name = ' '.join(cmdp)
        print("Setting Dolmade Name to " + self.name)

    def setupBase(self, cmdp):
        self.baseImg = ''.join(cmdp)
        print("Setting Base Docker Image to " + self.baseImg)

    def setupIngredient(self, cmdp):
        h = cmdp[0]
        fn = cmdp[1]
        dn = cmdp[2]
        u = cmdp[3]

        sys.stdout.write("Adding Ingredient " + dn + ":" + fn + ":" + h + ":" + u)
        ingr = Ingredient(h,fn,dn,u)
        
        for i in range(4,len(cmdp)):
            isInvalid = True
            for url_pf in ['http://', 'https://', 'ftp://', 'file://', 'gog://']:
                if (cmdp[i].startswith(url_pf)): 
                    sys.stdout.write(":" + cmdp[i])
                    ingr.addUrl(cmdp[i])
                    isInvalid = False
            if isInvalid:
                raise Exception("Malformed Url "+cmdp[i])

        self.ingredients.append(ingr)
        print("")

    def run(self, cmdp):
        print("Running as User:" + ' '.join(cmdp))
        self.runs.append(('user',cmdp))

    def runRoot(self, cmdp):
        print("Running as Root:" + ' '.join(cmdp))
        self.runs.append(('root',cmdp))

    def icon(self, cmdp):
        self.iconfn = ''.join(cmdp)
        print("Selecting Icon:" + self.iconfn)

    def setTarget(self, cmdp):
        self.runs.append(('setTarget', cmdp))
        print("Determine target path by running:" + ' '.join(cmdp))

    def setTargetBind(self, cmdp):
        targetBinds.append(cmdp)
        print("Bind mount for target run:" + join(cmdp))
        
    def build(self):
        print("Performing the dolmade build...")
        for i in self.ingredients: 
            i.retrieve()

        cmd = self.udocker + " mkrepo " + REPO_PATH
        print cmd
        try:
            outp = subprocess.check_output(cmd, shell=True, close_fds=True, stderr=subprocess.STDOUT)
        except:
            print("Repo exists already")

        cmd = self.udocker + " --repo=" + REPO_PATH + " pull " + self.baseImg+":"+self.version
        print cmd
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udocker + " --repo=" + REPO_PATH + " create " + self.baseImg+":"+self.version
        print("Installing the sucessfully built dolmade...")
        sha256 = subprocess.check_output(cmd, shell=True, close_fds=True)

        cmd = self.udocker + " --repo=" + REPO_PATH + " rm " + self.name
        print(cmd)
        subprocess.call(cmd, shell=True, close_fds=True)

        cmd = self.udocker + " --repo=" + REPO_PATH + " name " + sha256.strip() + " " + self.name
        print(cmd)
        subprocess.call(cmd, shell=True, close_fds=True)

        self.target = None
        self.targetPath = None
        self.sha256 = sha256.strip()

        for r in self.runs:
            (u,c) = r
            if (u == 'root'):
                cmd = self.udocker + " --repo=" + REPO_PATH + " run --volume=" + INST_PATH + ":/install --user=root --volume="+os.path.expanduser("~")+"/.Xauthority --hostenv --dri " + self.name + " " + "bash -c 'cd /install && " + ' '.join(c) + "'"
                subprocess.call(cmd, shell=True, close_fds=True)
            if (u == 'user'):
                cmd = self.udocker + " --quiet --repo=" + REPO_PATH + " run --volume=" + INST_PATH + ":/install --user="+getpass.getuser()+" --volume="+os.path.expanduser("~")+"/.Xauthority --hostenv --dri " + self.name + " " + "bash -c 'cd /install && " + ' '.join(c) + "'"
                print(cmd)
                subprocess.call(cmd, shell=True, close_fds=True)
            if (u == 'setTarget'):
                cmd = self.udocker + " --quiet --repo=" + REPO_PATH + " run --user="+getpass.getuser()+" --hostenv " + self.name + " bash -c '" + ' '.join(c) + "'"
                print(cmd)
                try:
                    outp = subprocess.check_output(cmd, shell=True, close_fds=True, stderr=subprocess.STDOUT)
                    outp = outp.strip()
                    self.target = ''.join(outp.split('/')[-1])
                    self.targetPath = '/'.join(outp.split('/')[:-1])
                except:
                    print("ERROR: could not determine target path!")

        if (self.target):
            print("Predefined target is "+self.target+", target path is "+self.targetPath)
            self.target = 'wine start "'+self.target+'"'
        else:
            print("No target predefined. Target launcher will be used.")
            self.target="./targetLauncher"
            self.targetPath="/usr/local/bin"

        iconInContainer = REPO_PATH+"/containers/"+self.sha256+"/ROOT/wineprefix/icon.png"
        open(iconInContainer, 'w+')
        cmd = self.udocker + " --quiet --repo=" + REPO_PATH + " run --user="+getpass.getuser()+" -v=" + INST_PATH+"/"+self.iconfn+":/"+self.iconfn+" -v="+iconInContainer+":/wineprefix/icon.png dolmades-runtime sh -c 'convert -adaptive-resize 128x128 /"+self.iconfn + "[0] " + "/wineprefix/icon.png'"
        print(cmd)
        subprocess.call(cmd, shell=True, close_fds=True)

        namefileInContainer = REPO_PATH+"/containers/"+self.sha256+"/ROOT/wineprefix/dolmadename"
        cleanName=self.name.replace('_',' ').replace('&',"_n_")
        subprocess.call("echo '"+cleanName+"' > "+namefileInContainer, shell=True, close_fds=True)

        with open(DESK_PATH + "/" + self.name + ".desktop", "w") as text_file:
            text_file.write("[Desktop Entry]\nEncoding=UTF-8\nValue=1.0\nType=Application\n")
            text_file.write("Name="+cleanName+"\nGenericName="+cleanName+"\nComment=" +cleanName+"\n")
            text_file.write("Icon="+REPO_PATH+"/containers/"+self.name+"/ROOT/wineprefix/icon.png"+"\n")
            text_file.write("Exec="+self.udocker+" --repo="+REPO_PATH + " run --user="+getpass.getuser()+" --volume="+os.path.expanduser("~")+"/.Xauthority --hostenv --dri " + self.name + " " + "bash -c '"+'cd "'+self.targetPath+'" && '+self.target+"'\n")
            text_file.write("Categories=Game;\n")
            text_file.write("Path="+os.path.expanduser("~")+"\n")

        st = os.stat(DESK_PATH + "/" + self.name + ".desktop")
        os.chmod(DESK_PATH + "/" + self.name + ".desktop", st.st_mode | stat.S_IEXEC)

class Main(object):
    dolmade = Dolmade()

    def executeCmd(self, cmdarg):
        """all supported commands"""
        cmds = { '': self.dolmade.dumpComment,
                 '#': self.dolmade.dumpComment,
                 'VERSION': self.dolmade.checkVersion,
                 'DOLMADE': self.dolmade.setupDolmade, 
                 'BASE': self.dolmade.setupBase,
                 'INGREDIENT': self.dolmade.setupIngredient,
                 'RUNUSER': self.dolmade.run,
                 'RUNROOT': self.dolmade.runRoot,
                 'ICON': self.dolmade.icon,
                 'SETTARGET': self.dolmade.setTarget,
                 'TARGETBIND': self.dolmade.setTargetBind }

        if len(cmdarg)<1:
            return

        cmd = cmdarg[0]
        arg = cmdarg[1:len(cmdarg)]

        if (cmd in cmds):
            cmds[cmd](arg)
        else:
            raise Exception('Unknown instruction ' + cmd + ":" + " ".join(cmdarg))


    def execute(self):
        if (len(sys.argv)==1):
            inputFileName = os.getcwd() + "/Dolmadefile"
        else:
            inputFileName = sys.argv[1];

        try:
            with open(inputFileName, "r") as dolmadeFile:
                cmdarg = list()
                while True:
                    line = dolmadeFile.readline();
                    if line:
                        if line.strip().startswith('#'):
                            continue
                        if line.startswith((' ','\t')) and not line.strip() == "":
                            cmdarg.append(line.strip())
                        else:
                            self.executeCmd(cmdarg)
                            cmdarg = list()
                            cmdarg.append(line.strip())
                    else:
                        break

                self.executeCmd(cmdarg)

        except (IOError, OSError):
            print("ERROR: Cannot open " + inputFileName)

        self.dolmade.build()

    def start(self):
        """Program start and exception handling"""
        try:
            createDirectories()
            exit_status = self.execute()
        except (KeyboardInterrupt, SystemExit):
            self.cleanup()
            return 1
        except:
            self.cleanup()
            raise
        else:
            self.cleanup()
            return exit_status

    def cleanup(self):
        print("Deleting all temporary files...")


if __name__ == "__main__":
    sys.exit(Main().start())
